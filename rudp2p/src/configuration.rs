use self::builder::ConfigurationBuilder;
use std::fmt::Debug;

mod builder;

/// # Configuration
///
/// Options configurables :
/// - port
/// - share connections
#[derive(Debug, Clone)]
pub struct Configuration {
    pub(crate) port: u16,
    pub(crate) share_connections: bool,
    #[cfg(feature = "ssl")]
    pub(crate) ssl: SSL,
}

impl Configuration {
    #[cfg(not(feature = "ssl"))]
    pub(crate) fn new() -> Self {
        Self {
            port: 9000,
            share_connections: false,
        }
    }

    #[cfg(feature = "ssl")]
    pub(crate) fn new(ssl: SSL) -> Self {
        Self {
            port: 9000,
            share_connections: false,
            ssl,
        }
    }

    /// Init the configuration builder.
    #[cfg(not(feature = "ssl"))]
    pub fn builder() -> ConfigurationBuilder {
        ConfigurationBuilder::new()
    }

    /// Init the configuration builder with SSL.
    #[cfg(feature = "ssl")]
    pub fn builder(ssl: SSL) -> ConfigurationBuilder {
        ConfigurationBuilder::new(ssl)
    }
}

/// # SSL
///
/// SSL configuration, we can change the size for a autogenerated key or the path of an existing key (RSA).
#[derive(Clone)]
#[cfg(feature = "ssl")]
pub struct SSL {
    pub(crate) private_key: openssl::rsa::Rsa<openssl::pkey::Private>,
    pub(crate) public_key: Vec<u8>,
}

#[cfg(feature = "ssl")]
impl Debug for SSL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SSL")
            .field("private_key", &self.private_key.size())
            .field("public_key", &self.public_key.len())
            .finish()
    }
}

#[cfg(feature = "ssl")]
impl Default for SSL {
    fn default() -> Self {
        use crate::utils::unwrap::unwrap_result;

        let private_key = unwrap_result(
            openssl::rsa::Rsa::generate(2048),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate default public key",
        );
        Self {
            private_key,
            public_key,
        }
    }
}

#[cfg(feature = "ssl")]
impl SSL {
    /// Autogenerate a key from a size.
    pub fn from_size(size: u32) -> Self {
        use crate::utils::unwrap::unwrap_result;

        let private_key = unwrap_result(
            openssl::rsa::Rsa::generate(size),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate public key from size",
        );
        Self {
            private_key,
            public_key,
        }
    }

    /// Generate a key from a file.
    pub fn from_file(path: String) -> Self {
        use crate::utils::unwrap::unwrap_result;
        use std::io::Read;

        let mut file = unwrap_result(
            std::fs::File::open(path.clone()),
            &format!("Unable to open file : {path}"),
        );
        let metadata = unwrap_result(std::fs::metadata(&path), "Unable to read metadata");
        let mut buffer = vec![0; metadata.len() as usize];
        unwrap_result(file.read(&mut buffer), "Buffer overflow");
        let private_key = unwrap_result(
            openssl::rsa::Rsa::private_key_from_pem(&buffer),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate public key from file",
        );
        Self {
            private_key,
            public_key,
        }
    }
}
