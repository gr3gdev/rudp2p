use self::builder::ConfigurationBuilder;

mod builder;

/// # SqliteMode
///
/// - Memory : the database is in memory, all data are losed if the Peer is closed.
/// - File : specify a path, all data are conserved if the Peer is closed.
///
/// NB: The Memory is more performant.
#[cfg(feature = "sqlite")]
#[derive(Debug, Default, Clone)]
pub enum SqliteMode {
    #[default]
    Memory,
    File(String),
}

/// # DatabaseUpgradeMode
///
/// Upgrade mode :
/// - AlwaysNew : DROP and CREATE all tables at each start
/// - Upgrade (default) : Update all tables
#[derive(Debug, Default, Clone)]
pub enum DatabaseUpgradeMode {
    AlwaysNew,
    #[default]
    Upgrade,
}

/// # Configuration
///
/// Options configurables :
/// - port
/// - share connections
/// - database mode (if feature sqlite)
/// - database url (if feature mysql)
#[derive(Debug, Default, Clone)]
pub struct Configuration {
    pub(crate) port: u16,
    pub(crate) share_connections: bool,
    pub(crate) database_upgrade_mode: DatabaseUpgradeMode,
    #[cfg(feature = "sqlite")]
    pub(crate) database_mode: SqliteMode,
    #[cfg(feature = "mysql")]
    pub(crate) database_url: Option<String>,
    #[cfg(feature = "ssl")]
    pub(crate) ssl: SSL,
}

impl Configuration {
    /// Init the configuration builder.
    #[cfg(not(feature = "ssl"))]
    pub fn builder() -> ConfigurationBuilder {
        ConfigurationBuilder::new()
    }

    /// Init the configuration builder with SSL.
    #[cfg(feature = "ssl")]
    pub fn builder(ssl: SSL) -> ConfigurationBuilder {
        ConfigurationBuilder::new(ssl)
    }

    #[cfg(all(feature = "sqlite", feature = "ssl"))]
    fn default_with_ssl(ssl: SSL) -> Self {
        Self {
            port: Default::default(),
            share_connections: Default::default(),
            database_upgrade_mode: DatabaseUpgradeMode::default(),
            database_mode: Default::default(),
            ssl,
        }
    }

    #[cfg(all(feature = "mysql", feature = "ssl"))]
    fn default_with_ssl(ssl: SSL) -> Self {
        Self {
            port: Default::default(),
            share_connections: Default::default(),
            database_upgrade_mode: DatabaseUpgradeMode::default(),
            database_url: Default::default(),
            ssl,
        }
    }
}

/// # SSL
///
/// SSL configuration, we can change the size for a autogenerated key or the path of an existing key (RSA).
#[derive(Debug, Clone)]
#[cfg(feature = "ssl")]
pub struct SSL {
    pub(crate) private_key: openssl::rsa::Rsa<openssl::pkey::Private>,
    pub(crate) public_key: Vec<u8>,
}

#[cfg(feature = "ssl")]
impl Default for SSL {
    fn default() -> Self {
        use crate::utils::unwrap::unwrap_result;

        let private_key = unwrap_result(
            openssl::rsa::Rsa::generate(2048),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate default public key",
        );
        Self {
            private_key,
            public_key,
        }
    }
}

#[cfg(feature = "ssl")]
impl SSL {
    /// Autogenerate a key from a size.
    pub fn from_size(size: u32) -> Self {
        use crate::utils::unwrap::unwrap_result;

        let private_key = unwrap_result(
            openssl::rsa::Rsa::generate(size),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate public key from size",
        );
        Self {
            private_key,
            public_key,
        }
    }

    /// Generate a key from a file.
    pub fn from_file(path: String) -> Self {
        use crate::utils::unwrap::unwrap_result;
        use std::io::Read;

        let mut file = unwrap_result(
            std::fs::File::open(path.clone()),
            &format!("Unable to open file : {path}"),
        );
        let metadata = unwrap_result(std::fs::metadata(&path), "Unable to read metadata");
        let mut buffer = vec![0; metadata.len() as usize];
        unwrap_result(file.read(&mut buffer), "Buffer overflow");
        let private_key = unwrap_result(
            openssl::rsa::Rsa::private_key_from_pem(&buffer),
            "Unable to generate SSL keys",
        );
        let public_key = unwrap_result(
            private_key.public_key_to_pem(),
            "Unable to generate public key from file",
        );
        Self {
            private_key,
            public_key,
        }
    }
}
