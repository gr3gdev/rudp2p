use self::builder::ConfigurationBuilder;

mod builder;

/// # SqliteMode
///
/// - Memory : the database is in memory, all data are losed if the Peer is closed.
/// - File : specify a path, all data are conserved if the Peer is closed.
///
/// NB: The Memory is more performant.
#[cfg(feature = "sqlite")]
#[derive(Debug, Default, Clone)]
pub enum SqliteMode {
    #[default]
    Memory,
    File(String),
}

/// # Configuration
///
/// Options configurables :
/// - port
/// - share connections
/// - database mode (if feature sqlite)
/// - database url (if feature mysql)
#[derive(Debug, Default, Clone)]
pub struct Configuration {
    pub(crate) port: u16,
    pub(crate) share_connections: bool,
    #[cfg(feature = "sqlite")]
    pub(crate) database_mode: SqliteMode,
    #[cfg(feature = "mysql")]
    pub(crate) database_url: Option<String>,
    #[cfg(feature = "ssl")]
    pub(crate) ssl: SSL,
}

impl Configuration {
    /// Init the configuration builder.
    #[cfg(not(feature = "ssl"))]
    pub fn builder() -> ConfigurationBuilder {
        ConfigurationBuilder::new()
    }

    /// Init the configuration builder with SSL.
    #[cfg(feature = "ssl")]
    pub fn builder(ssl: SSL) -> ConfigurationBuilder {
        ConfigurationBuilder::new(ssl)
    }

    #[cfg(all(feature = "sqlite", feature = "ssl"))]
    fn default_with_ssl(ssl: SSL) -> Self {
        Self {
            port: Default::default(),
            share_connections: Default::default(),
            database_mode: Default::default(),
            ssl,
        }
    }

    #[cfg(all(feature = "mysql", feature = "ssl"))]
    fn default_with_ssl(ssl: SSL) -> Self {
        Self {
            port: Default::default(),
            share_connections: Default::default(),
            database_url: Default::default(),
            ssl,
        }
    }
}

/// # SSL
///
/// SSL configuration, we can change the size for a autogenerated key or the path of an existing key (RSA).
#[derive(Debug, Clone)]
#[cfg(feature = "ssl")]
pub struct SSL {
    pub(crate) private_key: openssl::rsa::Rsa<openssl::pkey::Private>,
    pub(crate) public_key: Vec<u8>,
}

#[cfg(feature = "ssl")]
impl Default for SSL {
    fn default() -> Self {
        let private_key = openssl::rsa::Rsa::generate(2048)
            .or_else(|e| {
                log::error!("Unable to generate SSL keys : {e}");
                Err("Unable to generate SSL keys")
            })
            .unwrap();
        let public_key = private_key
            .public_key_to_pem()
            .expect("Unable to generate default public key");
        Self {
            private_key,
            public_key,
        }
    }
}

#[cfg(feature = "ssl")]
impl SSL {
    /// Autogenerate a key from a size.
    pub fn from_size(size: u32) -> Self {
        let private_key = openssl::rsa::Rsa::generate(size)
            .or_else(|e| {
                log::error!("Unable to generate SSL keys : {e}");
                Err("Unable to generate SSL keys")
            })
            .unwrap();
        let public_key = private_key
            .public_key_to_pem()
            .expect("Unable to generate public key from size");
        Self {
            private_key,
            public_key,
        }
    }

    /// Generate a key from a file.
    pub fn from_file(path: String) -> Self {
        use std::io::Read;

        let mut file =
            std::fs::File::open(path.clone()).expect(&format!("Unable to open file : {path}"));
        let metadata = std::fs::metadata(&path).expect("Unable to read metadata");
        let mut buffer = vec![0; metadata.len() as usize];
        file.read(&mut buffer).expect("Buffer overflow");
        let private_key = openssl::rsa::Rsa::private_key_from_pem(&buffer)
            .or_else(|e| {
                log::error!("Unable to generate SSL keys : {e}");
                Err("Unable to generate SSL keys")
            })
            .unwrap();
        let public_key = private_key
            .public_key_to_pem()
            .expect("Unable to generate public key from file");
        Self {
            private_key,
            public_key,
        }
    }
}
